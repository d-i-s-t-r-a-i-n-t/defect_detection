# defect_detection

Данный проект создается для распознавания и классификации дефектов на различных [деталях](https://drive.google.com/drive/folders/1pdHhjAuZXqzPTgiYeGQCL0cEMqkWQ2TN?usp=sharing) с использованием моделей семантической сегментации.

## Текущие условия

В наличии изображения деталей, но их размер и качество неоднородно: некоторые фотографии размыты, имеют низкий контраст и содержат шум.

## Поставленные задачи
**Предобработка изображений**  
   Исследовать и внедрить методы улучшения изображений, такие как повышение контрастности, резкости и удаление шума, чтобы позволить выявлять дефекты даже на некачественных снимках.

**Детекция и классификация дефектов**  
   - Разработать подход для автоматического обнаружения областей с дефектами.
   - Изучить и применить методы классификации, которые смогут определять тип дефекта на основе выделенных областей.
   - Определить подходящие модели и методы на основе успешных примеров в аналогичных задачах.

## Ожидаемый результат
Модель, способная по фотографии классифицировать деталь как «годная» или «брак», и в случае брака уточнять тип дефекта.

## Этапы работы
1. **Преодобработка изображений**  
   - Приведение размера изображений в датасете к размеру наибольшего из них с сохранением соотношения сторон (использование паддинга).
     </br> [Результат](https://drive.google.com/drive/folders/17AMCGiqYPZmsjtfcn-_Ui2mifFw8gBxA?usp=drive_link)
   - Изменение контрастности, резкости и устранение шума. Планируется доработать код в image_tuning.py и использовать после того, как будут получены результаты обучения модели на изображениях без предобработки.

2. **Аннотирование данных**  
   - Разметка дефектов с использованием [Labelbox](https://labelbox.com/).
   - Получение масок с сегментами классов с помощью /data_annotation/getting_masks.py в виде:
     </br> [цветных изображений](https://drive.google.com/drive/folders/1bk_XOIzYmclkM50vYSp_JUrctzX4MfqZ?usp=drive_link)
     </br> [темных изображений с номерами классов в размеченных пикселях](https://drive.google.com/drive/folders/1C8rMD6RQOG1r7TJLSQQvFhSgHibhp3Vb?usp=drive_link)

3. **Аугментирование датасета**
   Увеличение с помощью augmentation.py количества:
    </br> [изображений](https://drive.google.com/drive/folders/1aNRBj7TLM2FG7MXN9qo_-NICZTTlKGN8?usp=drive_link)
    </br> [изображений масок в цвете](https://drive.google.com/drive/folders/1vDr0QoJf49OeU_lV7bn60181vEjsVKcQ?usp=drive_link)
    </br> [изображений масок с номерами классов в размеченных пикселях](https://drive.google.com/drive/folders/1bEIbwkaR8Rg5ucYsw2YWYQV3zCi-uQkl?usp=drive_link)
   
5. **Выбор моделей**  
   - Были рассмотрены решения для распознавания дефектов на стали, среди которых наиболее распространенной является модель U-Net (2015). U-Net состоит из энкодера, понижающего разрешение изображения для извлечения признаков, и декодера, восстанавливающего его через деконволюцию. Прямые связи между уровнями энкодера и декодера позволяют объединять пространственную информацию из разных слоев, что снижает потерю данных при понижении разрешения и улучшает точность сегментации. Модель оптимальна для использования на ресурсах со средними требованиями по памяти, и ее скорость обучения относительно высока за счет упрощенной структуры.
   - Другой вариант — модель DeepLabV3 (2017), которая применяется для повышения точности сегментации благодаря использованию атриумных сверток. Вместо стандартного уменьшения разрешения, DeepLab сохраняет больше пространственной информации через атриумный пространственный пулинг и улучшает результаты сегментации с помощью алгоритма CRF (условного случайного поля). В результате, модель позволяет создавать более точные и четкие маски сегментации. В сравнении с U-Net, DeepLabV3 из-за осбенностей своего строения может требовать большего объема памяти и немного медленнее обучаться, но в то же время обеспечивать более высокую точность, чем нельзя пренебрегать в условиях имеющегося датасета с разной видимостью объектов детекции.
   
6. **Обучение моделей**  
   - Создание, настройка, обучение и оценка модели U-Net с помощью unet.py.
   - Создание, настройка, обучение и оценка модели DeepLabV3.

7. **Сравнение результатов обучения и выбор модели для детекции**  
   
## Текущие задачи
- Анализ результатов обучения, корректировка парамеров модели.
- Добавление обработок ошибок.
- Разбиение структуры кода на более логичные модули.
